# Co-coding
一个简单的LLM合作开发系统，使用简化的提示词和工作流程模拟
### Features
- 使用三个LLM分别作为需求分析、开发、测试
- 全自动开发非图形化的 python 脚本
- 自动补全依赖，运行测试
- 防止提示词注入
- 支持OpenAI及其兼容的API平台（如deepseek）
### Limitations
- 提示词有待优化（可以考虑结合提示词工程相关理论优化或者使用自动提示工程师）
- 对于复杂的开发任务无法实现全自动（环境准备、依赖不易自动处理，且涉及到安全性问题）
- 受LLM上下文长度和**自我错误强化**的影响，开发过程可能会“跑偏”
### Tests
```
开发一个排序程序，对输入（使用空格分隔）内容排序
```
```
帮我写脚本爬取这个网址的名言： http://quotes.toscrape.com/
目标字段：作者、名言文本、标签。
技术点：requests 获取 HTML，BeautifulSoup 定位 .quote 容器，提取 .text、.author、.tags 列表。
注意输出格式为json，只能用requests和beautifulsoup4这两个第三方库
```
```
输入：字符串 s 和模式串 p，其中 p 仅包含小写字母、. 和 *。
规则：
. 匹配任意单个字符。
* 匹配它之前的元素 0 次或多次。
匹配必须覆盖整个字符串（不允许部分匹配）。 
输出：返回布尔值，表示模式 p 是否能完全匹配字符串 s。
```
```
任务描述
请编写一个 Python 装饰器 @redis_cache(ttl)，用于缓存任意函数的调用结果到 Redis，并满足以下功能：
连接 Redis：使用 redis-py 客户端连接到本地或远程 Redis 实例。

生成缓存键：根据被装饰函数的名称及其位置参数和关键字参数，生成唯一的缓存键。
设置过期时间：在写入 Redis 时，为键设置可配置的 TTL（通过 SET 命令的 EX 参数或 SETEX 命令）。

缓存逻辑：
命中：若 Redis 中存在对应键，则直接反序列化并返回缓存值。
未命中：调用原函数获取结果，将结果序列化后写入 Redis，并返回该结果。

手动失效：提供一个辅助函数 invalidate_cache(func, *args, **kwargs)，用于删除指定函数调用对应的缓存键。
```
