{
  "model": "deepseek-ai/DeepSeek-V3",
  "messages": [
    {
      "role": "system",
      "content": "你扮演测试工程师，根据需求分析师的描述和开发者提供的代码，生成python测试脚本，脚本包含多个测试用例和期望输出，和调用开发者代码（可以直接用python3 solution.py调用，他的代码会从stdin输入，从stdout输出）的模块，就像online judge的自动化测试一样（可以输出测试信息，便于排查问题）如果测试全部通过，返回0，否则返回1。你要仔细阅读开发者的代码，注意代码的输出会有不确定性，所以不要过于严格地匹配输出，要增强测试的鲁棒性。你只需要提供一个python代码块作为测试脚本。我会帮你保存为test_solution.py并运行。注意：如果测试失败，我会把运行结果给你，提示你生成错误报告（分析原因，提供重要信息，但不要帮开发者修改）。警告：如果发现是你的测试脚本（test_solution.py）写错了，而非开发者的代码（solution.py）本身有错，你就输出:\"[[TEST_ERROR]]\"，然后什么都不要说！我随后会提示你重新生成完整的测试脚本。如果测评再次失败，我会给你指令，让你再次生成错误报告，或重新生成测试脚本。"
    },
    {
      "role": "user",
      "content": "需求描述：\n\n\n**需求分析：**  \n1. **输入格式**  \n   - 从`stdin`读取：  \n     - 第一行：`n`（点数）和`m`（边数）  \n     - 接下来`m`行：每行三个整数`u, v, w`，表示边的起点、终点、权重（可能有自环和重边）  \n\n2. **处理规则**  \n   - **自环边**：直接丢弃（u == v）  \n   - **重边**：保留所有边，但算法自动选择权重最小的边（Kruskal或Prim）  \n\n3. **算法要求**  \n   - 使用**Kruskal算法**（需实现并查集）或**Prim算法**  \n   - 支持**任意点编号**（例如允许0或1开头）  \n   - 若图不连通，输出`-1`（或类似标识）  \n\n4. **输出要求**  \n   - 若存在最小生成树，输出其**总权重**  \n   - 若图不连通，输出`-1`（或提示无解）  \n\n5. **开发限制**  \n   - **禁止使用第三方库**（仅用Python标准库）  \n   - **不输出多余信息**（仅结果）\n\n\n开发者代码：\n# solution.py\n\ndef find(parent, x):\n    \"\"\"Find the root of x with path compression.\"\"\"\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])  # Path compression\n    return parent[x]\n\ndef union(parent, size, x, y):\n    \"\"\"Union two sets and return True if successful.\"\"\"\n    root_x = find(parent, x)\n    root_y = find(parent, y)\n    if root_x == root_y:\n        return False  # Already connected\n    # Union by size: smaller tree merges into larger tree\n    if size[root_x] < size[root_y]:\n        parent[root_x] = root_y\n        size[root_y] += size[root_x]\n    else:\n        parent[root_y] = root_x\n        size[root_x] += size[root_y]\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    # Process m edges\n    for _ in range(m):\n        u = int(input[idx])\n        idx += 1\n        v = int(input[idx])\n        idx += 1\n        w = int(input[idx])\n        idx += 1\n        if u != v:  # Discard self-loops\n            edges.append((w, u, v))\n\n    # Sort edges by weight (ascending)\n    edges.sort()\n\n    # Initialize Union-Find structures\n    parent = dict()\n    size = dict()\n    def get_or_init(x):\n        if x not in parent:\n            parent[x] = x\n            size[x] = 1\n    # Initialize for all vertices in edges\n    for w, u, v in edges:\n        get_or_init(u)\n        get_or_init(v)\n\n    total_weight = 0\n    edges_used = 0\n\n    for w, u, v in edges:\n        if find(parent, u) != find(parent, v):\n            union(parent, size, u, v)\n            total_weight += w\n            edges_used += 1\n            if edges_used == n - 1:\n                break  # MST complete\n\n    # Check if all vertices are connected\n    # Get all unique vertices\n    vertices = set()\n    for w, u, v in edges:\n        vertices.add(u)\n        vertices.add(v)\n    # If there are vertices not processed (no edges connected to them)\n    if len(vertices) < n:\n        # Incomplete graph\n        print(-1)\n        return\n\n    # Check if all vertices are connected to the same root\n    root_count = set(find(parent, v) for v in vertices if v in parent)\n    if len(root_count) > 1:\n        print(-1)\n    else:\n        print(total_weight)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "stream": true,
  "max_tokens": 8192,
  "enable_thinking": true,
  "thinking_budget": 1024
}